# PokedexApi
A Pokedex Web API application built using the .NET 5 Web API framework that retrieves a Pokemon's basic information using public APIs.
## How to Run
I personally used Visual Studio to develop, test and run the project, but there are multiple ways to run this project. The different methods are listed below.

**First, clone the repo in to the desired folder using CLI `git clone https://github.com/sanjayh94/PokedexApi/` or your favourite IDE/GUI tool.**

*You will need git CLI installed for this command to work, Find instructions [here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)*
### Docker
1. Install Docker if you haven't already. Find instructions [here](https://docs.docker.com/get-docker/). _Note: Verify Docker is running on Linux containers mode._
2. Open your preferred terminal and Navigate to the directory where you cloned the repo earlier. For example `cd ~/repos/PokedexApi`
3. Build Image `docker build -f PokedexApi/Dockerfile -t pokedexapi .`
4. Run Image `docker run --rm -p 5000:80 pokedexapi`. 

**Note: the first port denoted after the `-p` parameter is the host port where the application is exposed i.e. port 5000 in this case. Your endpoint port will change depending on the port you specified here.** For example `http://localhost:5000/pokemon/{pokemonName}`. Ignore the `Now listening on: http://[::]:80` in the logs.

### Visual Studio (or VSCode)
1. Install Visual Studio (or VSCode if preferred) from [here](https://visualstudio.microsoft.com/downloads/).
2. Navigate to the directory where you cloned the repo earlier and open the Solution from the `PokedexApi.sln` file in the root of the directory.
3. Hit the Run icon and the project should build and launch in a browser.
4. Take a note of the url and port when the browser launches to test the endpoint. For example, `http://localhost:5000/`

_Note: You will have to Install the C# extension and/or the .NET SDK, if you are planning to use VSCode. It should automatically prompt you to install when you open the project for the first time._

### dotnet CLI
1. Install .NET SDK (CLI tools are bundled) if you haven't already. Find instructions [here](https://dotnet.microsoft.com/download). If you installed Visual Studio in the previous step, .NET CLI should already be installed.
2. Open your preferred terminal and Navigate to the directory where you cloned the repo earlier. For example `cd ~/repos/PokedexApi`
3. Build the project using `dotnet build` command. Make sure the Build succeeds at this stage
4. Run the 'PokedexApi' project using `dotnet run --project PokedexApi`. Make note of the url and port from the log `Now listening on: http://localhost:5000`

## Testing endpoints
Run the project using any of the methods above, and then use your preferred API client (Postman, httpie, curl or even your browser!) to test these endpoints. Make sure the the correct port is used when querying the endpoints. Replace the port `5000` with your own.

+ GET `http://localhost:5000/swagger` : Autogenerated OpenAPI swagger documentation. You can also use this to try the endpoints out. Click the appropriate endpoint and click the `Try it out` button. Input a Pokemon Name in the parameters box and click the `Execute` button to initiate an API call.
+ GET `http://localhost:5000/health` : Basic healthcheck
+ GET `http://localhost:5000/pokemon/{pokemonName}` : Given a Pokemon name, returns standard Pokemon description and additional information
  + Example call using httpie `http localhost:5000/pokemon/onix`
  + Response would be 
  ```json
  {
    "description": "As it grows, the stone portions of its body harden to become similar to a diamond, but colored black.",
    "habitat": "cave",
    "isLegendary": false,
    "name": "onix"
  }
  ```
  
+ GET `http://localhost:5000/pokemon/translated/{pokemonName}` : Given a Pokemon name, return translated Pokemon description and other basic infomation. Conditions apply such that, If the Pokemon's habitat is `cave` or it's a legendary Pokemon then Yoda translation will be applied. The rest of the Pokemons will have the Shakespeare translation. The standard description is returned on fallback (such as if the translation API is rate-limited)
  + Example call using httpie `http localhost:5000/pokemon/translated/onix`
  + Response would be 
  ```json
  {
    "description": "As it grows,To become similar to a diamond,  the stone portions of its body harden,But colored black.",
    "habitat": "cave",
    "isLegendary": false,
    "name": "onix"
  }
  ``` 
  + _Note: Be mindful of making multiple requests to this endpoint as the public translation API is rate-limited to 5 calls per hour. However the app is configured to return a standard description if that happens._

## Running Tests

The project consists of a number of Unit Tests and Smoke Tests. Unit tests test methods in isolation of dependencies and Smoke Tests are end-to-end tests that involve making API calls to the project and the third party APIs as well. Smoke tests are useful for a final sanity check before deploying to Production.

Note: Smoke tests make actual API calls. The `/pokemon/translated` is rate-limited by the external API to 5 calls per hour, so there are chances it may fail. Therefore these tests are skipped. To un-skip them, the `[Fact(Skip)]` attribute code can be replaced with `[Fact]`.

```C#
// File: /PokemonApi.Tests/PokemonSmokeTests.cs

 [Fact(Skip = "Skipping Translated Endpoint as Public Endpoint is ratelimited to 5 calls per hour")]
  //[Fact]
  public async Task Get_PokemonTranslated_Cave_ReturnsExpectedJsonContent_YodaTranslation()
  {
      // Arrange
      string pokemonName = "onix";
      string url = $"/pokemon/translated/{pokemonName}";
      
  // rest of the code ommitted
```

### Using Visual Studio (or VSCode)
![Running Tests in Visual Studio](https://user-images.githubusercontent.com/94787187/143479724-69f4d5f5-9902-4aa0-8d5e-7f8b3ecd7aa9.png)

1. Open the solution in Visual Studio
2. Open the Test Explorer window/tab and hit the Run Tests button

### Using dotnet CLI
1. Make sure .NET CLI is installed from the previous steps
2. Open your preferred terminal and Navigate to the directory where you cloned the repo earlier. For example `cd ~/repos/PokedexApi`
3. Run the command `dotnet test`

![dotnet cli test](https://user-images.githubusercontent.com/94787187/143482845-0e6cf6f7-4e95-4ffc-be9f-981694bcc520.png)

## Design Decisions and Code Structure

I have used the .NET 5.0 (a.k.a. [ASP.NET Core 5.0](https://dotnet.microsoft.com/apps/aspnet/apis)) Web API framework in C# to write this application. .NET 5.0 is an open source and cross platform .NET implementation to build websites and APIs. I preferred to build this task in .NET as it encourages good coding practices such as Seperation of Concerns (or Single Responsibility Principle) through the MVC Design pattern, and Dependency Inversion principle through [Dependency Injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1). Also, C# being an OOP language, it is strictly typed, thus easier to read. The Structure of .NET can be easier to read if the code follows the best practices and conventions. Becuase of Dependency Injection, Classes are dependent on abstractions (Interfaces), rather than implementations which make the codebase very modular and easier to unit test.

The following image (taken from [microsoft's documentation page](https://docs.microsoft.com/en-gb/aspnet/core/tutorials/first-web-api?view=aspnetcore-5.0)) shows the architecture of the MVC design pattern of Web API application

![Web API architecture](https://user-images.githubusercontent.com/94787187/143485336-ccb99214-29e8-408b-8e32-4006ab4a8a4b.png)


.NET Core Web APIs are also easily configurable using middlewares such as adding request logging or adding retry logic to handle transient API failures.

![Middleware](https://user-images.githubusercontent.com/94787187/143485645-5c069a55-7d30-4432-ae74-9cf391d9340e.png)

The `Startup.cs` file is the starting point of the application when the Application is launched through the `Program.cs` file. Middlewares and Dependency Injection services can be configured in the `Startup.cs` file. Middleware can also be used to automatically generate openAPI Swagger documentation.

```C#
// Startup.cs file

 // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {

            services.AddControllers();

            // Register ASP.Net Core Healthcheck Middleware for container liveness checks. Basic healthchecks not tied to any subsystems. Access at '/health'
            services.AddHealthChecks(); 

            // OpenApi SwaggerDoc Generator
            services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "PokedexApi", Version = "v1" });
            });
            
   // rest of the code omitted
```

![Swagger doc](https://user-images.githubusercontent.com/94787187/143486385-9db57084-123d-4279-9900-c107d74f733d.png)

The tests are located in a seperate (but linked) project called `PokedexApi.Tests`. The tests contain Unit tests and Smoke tests. The Tests project uses the XUnit Framework for testing, Moq library for Mocking and the FluentAssertions for better assertions.

The `Controllers/PokemonController.cs` file is where the routes are handled. The Controller is responsible for handling user requests only. The heavy lifting is passed onto Services such as `PokemonService.cs` and `TranslatorService.cs`. Notice how the Interfaces for the services `IPokemonService` and `ITranslationSerice` are used in the Constructor instead of the actual implementation class using Dependency Injection to avoid being dependent on the implementation class.

```C#
// File: PokedexApi/Controllers/PokemonController

    [Route("pokemon")]
    [ApiController]
    public class PokemonController : ControllerBase
    {
        #region DependencyInjectionVariables
        private readonly ILogger<PokemonController> _logger;
        private readonly IPokemonService _pokemonService;
        private readonly ITranslatorService _translatorService;
        #endregion

        public PokemonController(IPokemonService pokemonService, ITranslatorService translatorService, ILogger<PokemonController> logger)
        {
            //  Setting up the pokemonService using Dependency Injection. This service will call the third-party PokeApi API and retrieve Pokemon Info for the controller
            _pokemonService = pokemonService;
            _translatorService = translatorService;
            _logger = logger; // Setting up the logging service using Dependency Injection
        }

        
        [HttpGet("{pokemonName}")]
        public async Task<ActionResult<PokemonDTO>> GetPokemon(string pokemonName)
        {
            try
            {
                var pokemon = await _pokemonService.GetPokemon(pokemonName);

                if (pokemon.ApiResponseStatus == System.Net.HttpStatusCode.NotFound)
                {
                    return NotFound();
                }
                
                // rest of the code omitted
```


## Approach for Production
Further are points where I would do things differently for production

#### Deployment & Hosting
App would be preferably deployed in container(s) on a Kubernetes platform. Can be running on multiple pods and load-balanced. It would be easier to have an distributed architecture since the App doesn't have State or a Persistence layer at the moment. The App is designed to be fault tolerant i.e. when a pod dies, it would be easily brought back online when redeployed, or when the app needs to be scaled. Can also do Canary deployments.

#### Input Validation
Input Validation or Input Sanitisation can be important in API applications from a Security point of view. Especially when POST routes are implemented. This can be configured using a library such as [Fluent Validation](https://fluentvalidation.net/)

#### Performance Monitoring
Performance monitoring and Load testing can be critical to API apps. Monitoring can help detect failures or when an application is under load. Load testing can help simulate the load and assess the resiliency of the app. Performance monitoring can be done through platforms such as Prometheus, New Relic, Splunk, etc.

#### Logging
The App is configured to use the [Serilog](https://serilog.net/) library for structured event logging. The benefit of using this library is that logging only needs to be set up once and then the logs can be provided to any of the configurable providers such as [Splunk, Prometheus, Console, File, GrayLog, S3 and even Email](https://github.com/serilog/serilog/wiki/Provided-Sinks)! At the moment the App is configured to write to the console, but ideally would like to send it to a log consuming platform such as Splunk

```C#
// File: Program.cs

    public class Program
    {
        public static void Main(string[] args)
        {
            // Configure Serilog Logging.
            // Serilog provides structured API event logs that can be easily extended to any supported log consuming platforms such as Splunk, Prometheus, Console, File, GrayLog, S3 and even Email!
            // https://github.com/serilog/serilog/wiki/Provided-Sinks
            // Setting up logging to Console for now

            #region SerilogConfiguration
            Log.Logger = new LoggerConfiguration()
            .MinimumLevel.Override("Microsoft.AspNetCore", LogEventLevel.Warning) // Set logging level to warning and above from ASP.NET Core components as it can get chatty
            .Enrich.FromLogContext()
            .WriteTo.Console() // Writing logs to Console
            .CreateLogger();
            
            // rest of the code omitted
```

#### Caching
Cache responses locally (or even a Redis Cache) to avoid making multiple calls to the external APIs for the same GET calls.

#### Configuration/ Secret Management
An app mostly has configuration files and/or secrets. Storing and fetching them from a secure vault (Such as Hashicorp vault) to avoid storing them in repos

#### API Gateway
The app can be placed behind an API gateway to manage and secure APIs including loadbalancing, authentication and SSL.

#### Resiliency (Retry Logic)
The app is configured to use a retry and transient fault handling library called [Polly](https://github.com/App-vNext/Polly). The Polly libraries automatically retries external HTTP calls configured according to policies, if they are experiencing transient failure. Developers can use the library to configure policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback. At the moment, the app is configured with a simple retry policy but can use more robust policies in production if needed.

```C#
// File: Startup.cs

         public void ConfigureServices(IServiceCollection services)
        {
            // Code omitted here ....
            
            #region RegisterServicesForDependencyInjection
            // Registers the PokemonService and Translator as a Dependency Injection container 
            // As we are using the service for HTTP REST API Calls, we register the service as an HTTP client

            services.AddHttpClient<IPokemonService, PokemonService>()
                .AddTransientHttpErrorPolicy(p =>
                    p.WaitAndRetryAsync(3, _ => TimeSpan.FromMilliseconds(600)));

            services.AddHttpClient<ITranslatorService, TranslatorService>()
                .AddTransientHttpErrorPolicy(p =>
                    p.WaitAndRetryAsync(3, _ => TimeSpan.FromMilliseconds(600)));

            // Additionally, the above services are configured with a third party library called Polly which handles transient fault handling for API calls
            // It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner.

            // In the preceding code, a WaitAndRetryAsync policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts.
            #endregion
        }
```

#### More Testing
More testing Coverage :)

#### CI/CD Pipelines & Deployment Automation
Deployment of the app can be handled through CI/CD pipelines and automation tools. Unit tests and Smoke tests can be used as gates before deployment. All of the tools mentioned above can be integrated using CI/CD.

