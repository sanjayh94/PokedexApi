# PokedexApi
A Pokedex Web API application built in the .NET 5 Web API framework that retrieves a Pokemon's basic information using public APIs.
## How to Run
I personally used Visual Studio to develop, test and run the project, but there are multiple ways to run this project. The different methods are listed below.

**First, clone the repo in to the desired folder using CLI `git clone https://github.com/sanjayh94/PokedexApi/` or your favourite IDE/GUI tool.**

*You will need git CLI installed for this command to work, Find instructions [here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)*
### Docker
1. Install Docker if you haven't already. Find instructions [here](https://docs.docker.com/get-docker/). _Note: Verify Docker is running on Linux containers mode._
2. Open your preferred terminal and Navigate to the directory where you cloned the repo earlier. For example `cd ~/repos/PokedexApi`
3. Build Image `docker build -f PokedexApi/Dockerfile -t pokedexapi .`
4. Run Image `docker run --rm -p 5000:80 pokedexapi`. 

**Note: the first port denoted after the `-p` parameter is the host port where the application is exposed i.e. port 5000 in this case. Your endpoint port will change depending on the port you specified here.** For example `http://localhost:5000/pokemon/{pokemonName}`. Ignore the `Now listening on: http://[::]:80` in the logs.

### Visual Studio (or VSCode)
1. Install Visual Studio (or VSCode if preferred) from [here](https://visualstudio.microsoft.com/downloads/).
2. Navigate to the directory where you cloned the repo earlier and open the Solution from the `PokedexApi.sln` file in the root of the directory.
3. Hit the Run icon and the project should build and launch in a browser.
4. Take a note of the url and port when the browser launches to test the endpoint. For example, `http://localhost:5000/`

_Note: You will have to Install the C# extension and/or the .NET SDK, if you are planning to use VSCode. It should automatically prompt you to install when you open the project for the first time._

### dotnet CLI
1. Install .NET SDK (CLI tools are bundled) if you haven't already. Find instructions [here](https://dotnet.microsoft.com/download). If you installed Visual Studio in the previous step, .NET CLI should already be installed.
2. Open your preferred terminal and Navigate to the directory where you cloned the repo earlier. For example `cd ~/repos/PokedexApi`
3. Build the project using `dotnet build` command. Make sure the Build succeeds at this stage
4. Run the 'PokedexApi' project using `dotnet run --project PokedexApi`. Make note of the url and port from the log `Now listening on: http://localhost:5000`

## Testing endpoints
Run the project using any of the methods above, and then use your preferred API client (Postman, httpie, curl or even your browser!) to test these endpoints. Make sure the the correct port is used when querying the endpoints. Replace the port `5000` with your own.

+ GET `http://localhost:5000/swagger` : Autogenerated OpenAPI swagger documentation. You can also use this to try the endpoints out. Click the appropriate endpoint and click the `Try it out` button. Input a Pokemon Name in the parameters box and click the `Execute` button to initiate an API call.
+ GET `http://localhost:5000/health` : Basic healthcheck
+ GET `http://localhost:5000/pokemon/{pokemonName}` : Given a Pokemon name, returns standard Pokemon description and additional information
  + Example call using httpie `http localhost:5000/pokemon/onix`
  + Response would be 
  ```json
  {
    "description": "As it grows, the stone portions of its body harden to become similar to a diamond, but colored black.",
    "habitat": "cave",
    "isLegendary": false,
    "name": "onix"
  }
  ```
  
+ GET `http://localhost:5000/pokemon/translated/{pokemonName}` : Given a Pokemon name, return translated Pokemon description and other basic infomation. Conditions apply such that, If the Pokemon's habitat is `cave` or it's a legendary Pokemon then Yoda translation will be applied. The rest of the Pokemons will have the Shakespeare translation. The standard description is returned on fallback (such as if the translation API is rate-limited)
  + Example call using httpie `http localhost:5000/pokemon/translated/onix`
  + Response would be 
  ```json
  {
    "description": "As it grows,To become similar to a diamond,  the stone portions of its body harden,But colored black.",
    "habitat": "cave",
    "isLegendary": false,
    "name": "onix"
  }
  ``` 
  + _Note: Be mindful of making multiple requests to this endpoint as the public translation API is rate-limited to 5 calls per hour. However the app is configured to return a standard description if that happens._

## Running Tests

The project consists of a number of Unit Tests and Smoke Tests. Unit tests test methods in isolation of dependencies and Smoke Tests are end-to-end tests that involve making API calls to the project and the third party APIs as well. Smoke tests are useful for a final sanity check before deploying to Production.

Note: Smoke tests make actual API calls. The `/pokemon/translated` is rate-limited by the external API to 5 calls per hour, so there are chances it may fail. Therefore these tests are skipped. To un-skip them, the `[Fact(Skip)]` attribute code can be replaced with `[Fact]`.

```C#
// File: /PokemonApi.Tests/PokemonSmokeTests.cs

 [Fact(Skip = "Skipping Translated Endpoint as Public Endpoint is ratelimited to 5 calls per hour")]
  //[Fact]
  public async Task Get_PokemonTranslated_Cave_ReturnsExpectedJsonContent_YodaTranslation()
  {
      // Arrange
      string pokemonName = "onix";
      string url = $"/pokemon/translated/{pokemonName}";
      
  // rest of the code ommitted
```

### Using Visual Studio (or VSCode)
![Running Tests in Visual Studio](https://user-images.githubusercontent.com/94787187/143479724-69f4d5f5-9902-4aa0-8d5e-7f8b3ecd7aa9.png)

1. Open the solution in Visual Studio
2. Open the Test Explorer window/tab and hit the Run Tests button

### Using dotnet CLI
1. Make sure .NET CLI is installed from the previous steps
2. Open your preferred terminal and Navigate to the directory where you cloned the repo earlier. For example `cd ~/repos/PokedexApi`
3. Run the command `dotnet test`

![dotnet cli test](https://user-images.githubusercontent.com/94787187/143482845-0e6cf6f7-4e95-4ffc-be9f-981694bcc520.png)

## Design Decisions and Code Structure

I have used the .NET 5.0 (a.k.a. [ASP.NET Core 5.0](https://dotnet.microsoft.com/apps/aspnet/apis)) Web API framework in C# to write this application. .NET 5.0 is an open source and cross platform .NET implementation to build websites and APIs. I preferred to build this task in .NET as it encourages good coding practices such as Seperation of Concerns (or Single Responsibility Principle) through the MVC Design pattern, and Dependency Inversion principle through [Dependency Injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1). Also, C# being an OOP language, it is strictly typed, thus easier to read. The Structure of .NET can be easier to read if the code follows the best practices and conventions. Becuase of Dependency Injection, Classes are dependent on abstractions (Interfaces), rather than implementations which make the codebase very modular and easier to unit test.

The following image (taken from [microsoft's documentation page](https://docs.microsoft.com/en-gb/aspnet/core/tutorials/first-web-api?view=aspnetcore-5.0)) shows the architecture of the MVC design pattern of Web API application

![Web API architecture](https://user-images.githubusercontent.com/94787187/143485336-ccb99214-29e8-408b-8e32-4006ab4a8a4b.png)


.NET Core Web APIs are also easily configurable using middlewares such as adding request logging or adding retry logic to handle transient API failures.

![Middleware](https://user-images.githubusercontent.com/94787187/143485645-5c069a55-7d30-4432-ae74-9cf391d9340e.png)

The `Startup.cs` file is the starting point of the application when the Application is launched through the `Program.cs` file. Middlewares and Dependency Injection services can be configured in the `Startup.cs` file. Middleware can also be used to automatically generate openAPI Swagger documentation.

```C#
// Startup.cs file

 // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {

            services.AddControllers();

            // Register ASP.Net Core Healthcheck Middleware for container liveness checks. Basic healthchecks not tied to any subsystems. Access at '/health'
            services.AddHealthChecks(); 

            // OpenApi SwaggerDoc Generator
            services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "PokedexApi", Version = "v1" });
            });
            
   // rest of the code omitted
```

![Swagger doc](https://user-images.githubusercontent.com/94787187/143486385-9db57084-123d-4279-9900-c107d74f733d.png)

The tests are located in a seperate (but linked) project called `PokedexApi.Tests`. The tests contain Unit tests and Smoke tests. The Tests project uses the XUnit Framework for testing, Moq library for Mocking and the FluentAssertions for better assertions.


## Approach for Production
Further are points where I would do things differently for production

#### Deployment & Hosting

#### Input Validation

#### Performance Monitoring

#### Logging

#### Caching

#### Configuration/ Secret Management

#### API Gateway

#### CI/CD Pipelines & Deployment Automation

#### Resiliency (Retry Logic)

#### More Testing

